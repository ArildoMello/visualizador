<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GML - Ocorrências 2025</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js" defer></script>
  <style>
    :root{
      --bg1:#0a0f1f; --bg2:#0d1533; --card:#111a3a;
      --txt:#eaf1ff; --muted:#a9b7e3; --line:#22306b;
      --a:#00e6ff; --b:#2f7bff; --c:#7c4dff; --ok:#00d69d; --warn:#ffb020; --err:#ff5577;
      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Ubuntu,Arial; color:var(--txt);
      background: radial-gradient(1200px 800px at 15% -10%, rgba(47,123,255,.25), transparent 60%),
                  radial-gradient(900px 600px at 85% 110%, rgba(124,77,255,.18), transparent 60%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      padding:24px;
    }
    .wrap{max-width:1200px;margin:0 auto}
    .title{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:18px}
    h1{
      font-size: clamp(20px, 2.6vw, 34px);
      margin:0; letter-spacing:.5px; font-weight:900;
      background: linear-gradient(90deg, var(--a), var(--b));
      -webkit-background-clip:text; background-clip:text; color:transparent;
      text-shadow: 0 0 18px rgba(0,230,255,.24);
    }
    .badge{font-size:12px;color:var(--muted);opacity:.9}

    .panel{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); border:1px solid var(--line); border-radius:18px; box-shadow:var(--shadow)}
    .controls{display:grid;grid-template-columns:repeat(12,1fr);gap:12px;padding:16px}
    .control{grid-column: span 4; min-width:200px}
    .control label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px 6px}
    select{width:100%; padding:12px 14px; border-radius:12px; border:1px solid var(--line); background:#0d1635; color:var(--txt); outline:none; box-shadow: inset 0 0 0 1px rgba(0,230,255,.08)}
    select:focus{border-color:var(--b); box-shadow:0 0 0 3px rgba(47,123,255,.25)}

    .dash{margin-top:18px; padding:16px}
    .chartBox{position:relative; height:min(65vh,680px);}

    .grid{margin-top:16px; border-top:1px dashed var(--line); display:grid; grid-template-columns:repeat(12,1fr); gap:12px; padding:16px}
    .card{grid-column: span 4; background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px}
    .card h3{margin:0 0 6px; font-size:13px; color:var(--muted)}
    .card .v{font-size:24px; font-weight:800}

    /* Esconde qualquer log interno */
    #log{display:none}

    @media (max-width: 900px){ .control{grid-column: span 12} .card{grid-column: span 12} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <h1>Guarda Municipal de Ocorrências — 2025</h1>
      <span class="badge" id="statusText">Carregando…</span>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="control">
          <label>Categorias</label>
          <select id="category"></select>
        </div>
        <div class="control">
          <label>Visualizar por</label>
          <select id="view">
            <option value="regions">Regiões</option>
            <option value="times">Horários</option>
            <option value="days">Dias da Semana</option>
          </select>
        </div>
        <div class="control">
          <label>Métrica</label>
          <select id="metric">
            <option value="N° Ocorrência">N° Ocorrência</option>
            <option value="Detidos Maiores">Detidos Maiores</option>
            <option value="Menores">Menores</option>
          </select>
        </div>
      </div>

      <div class="dash">
        <div class="chartBox panel">
          <canvas id="chart"></canvas>
        </div>
        <div class="grid">
          <div class="card"><h3>Total (categoria)</h3><div class="v" id="kpiTotal">—</div></div>
          <div class="card"><h3>Pico (rótulo)</h3><div class="v" id="kpiPeak">—</div></div>
          <div class="card"><h3>Última atualização</h3><div class="v" id="kpiAt">—</div></div>
        </div>
        <div class="status" id="log"></div>
      </div>
    </div>
  </div>

  <script>
  // Configurável: ID da planilha e gid da aba
  const SHEET_ID = '1rO6VZbiBqMpHW8oyte4irNPGZPL1zUif1mftR4tYtUM';
  const GID = '0';
  const CSV_URL = `https://corsproxy.io/?${encodeURIComponent(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${GID}`)}`;

  window.addEventListener('DOMContentLoaded', () => {
    const els = {
      category: document.getElementById('category'),
      view: document.getElementById('view'),
      metric: document.getElementById('metric'),
      status: document.getElementById('statusText'),
      log: document.getElementById('log'),
      kpiTotal: document.getElementById('kpiTotal'),
      kpiPeak: document.getElementById('kpiPeak'),
      kpiAt: document.getElementById('kpiAt'),
      chart: document.getElementById('chart'),
    };

    let CHART;
    let DATA = { headers: [], rows: [], categories: [], labels: { regions: [], times: [], days: [] } };

    // Cabeçalhos reais da sua planilha
    const HEADER_MAP = {
      tipo: ['Tipo final','Tipo Final','Tipo'],
      categoria: ['Categoria'],
      ocorrencias: ['N° Ocorrência','N° Ocorrencia','Nº Ocorrência','Numero Ocorrencia'],
      maiores: ['Detidos Maiores','Maiores'],
      menores: ['Menores'],
      regioes: ['CENTRO','LESTE','OESTE','NORTE','SUL','DISTRITOS','SEM DADOS'],
      periodos: ['MANHÃ','TARDE','NOITE','MADRUGADA'],
      dias: ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado']
    };

    const setStatus = (t) => els.status.textContent = t;

    function csvToMatrix(text){
      if (!text.trim()) throw new Error('CSV vazio ou inválido');
      const lines = text.replace(/\r/g,'').split(/\n+/).filter(Boolean);
      return lines.map(l => {
        const out = []; let cur = ''; let q = false;
        for (let i=0;i<l.length;i++){
          const ch = l[i];
          if (ch==='"') { q = !q; continue; }
          if (ch===',' && !q) { out.push(cur); cur=''; continue; }
          cur += ch;
        }
        out.push(cur);
        return out.map(s=>s.trim());
      });
    }

    const coerceNumber = (v) => {
      if (v == null || v === '') return 0;
      const n = Number(String(v).replace(/\./g,'').replace(',', '.'));
      if (!Number.isFinite(n)) {
        console.warn(`Valor inválido encontrado: "${v}"`);
        return 0;
      }
      return n;
    };

    function findIndex(headers, names){
      for (const n of names){ const i = headers.indexOf(n); if (i !== -1) return i; }
      return -1;
    }

    function normalizeData(matrix){
      if (!matrix.length) throw new Error('Matriz vazia');
      const headers = matrix[0].map(h => String(h).trim());
      const rowsArr = matrix.slice(1);

      const idx = {
        tipo: findIndex(headers, HEADER_MAP.tipo),
        categoria: findIndex(headers, HEADER_MAP.categoria),
        ocorrencias: findIndex(headers, HEADER_MAP.ocorrencias),
        maiores: findIndex(headers, HEADER_MAP.maiores),
        menores: findIndex(headers, HEADER_MAP.menores)
      };
      const idxReg = HEADER_MAP.regioes.map(h => headers.indexOf(h));
      const idxPer = HEADER_MAP.periodos.map(h => headers.indexOf(h));
      const idxDia = HEADER_MAP.dias.map(h => headers.indexOf(h));

      // Mapear linhas brutas
      const rawRows = rowsArr.map(r => {
        const o = {};
        o['Categoria'] = r[idx.categoria] || '';
        o['N° Ocorrência'] = coerceNumber(r[idx.ocorrencias]);
        o['Detidos Maiores'] = coerceNumber(r[idx.maiores]);
        o['Menores'] = coerceNumber(r[idx.menores]);
        HEADER_MAP.regioes.forEach((h, i) => { const j = idxReg[i]; o[h] = coerceNumber(j >= 0 ? r[j] : 0); });
        HEADER_MAP.periodos.forEach((h, i) => { const j = idxPer[i]; o[h] = coerceNumber(j >= 0 ? r[j] : 0); });
        HEADER_MAP.dias.forEach((h, i) => { const j = idxDia[i]; o[h] = coerceNumber(j >= 0 ? r[j] : 0); });
        return o;
      }).filter(o => o['Categoria']); // Filtrar apenas linhas com categoria

      // Agregar por categoria
      const grouped = {};
      rawRows.forEach(r => {
        const cat = r['Categoria'];
        if (!grouped[cat]) {
          grouped[cat] = {
            'Categoria': cat,
            'N° Ocorrência': 0,
            'Detidos Maiores': 0,
            'Menores': 0
          };
          HEADER_MAP.regioes.forEach(h => grouped[cat][h] = 0);
          HEADER_MAP.periodos.forEach(h => grouped[cat][h] = 0);
          HEADER_MAP.dias.forEach(h => grouped[cat][h] = 0);
        }
        grouped[cat]['N° Ocorrência'] += r['N° Ocorrência'];
        grouped[cat]['Detidos Maiores'] += r['Detidos Maiores'];
        grouped[cat]['Menores'] += r['Menores'];
        HEADER_MAP.regioes.forEach(h => grouped[cat][h] += r[h]);
        HEADER_MAP.periodos.forEach(h => grouped[cat][h] += r[h]);
        HEADER_MAP.dias.forEach(h => grouped[cat][h] += r[h]);
      });

      const categories = Object.keys(grouped);
      DATA.headers = headers;
      DATA.rows = Object.values(grouped);
      DATA.categories = categories;
      DATA.labels = {
        regions: HEADER_MAP.regioes,
        times: HEADER_MAP.periodos,
        days: HEADER_MAP.dias
      };
    }

    async function fetchCSV(){
      try {
        const res = await fetch(CSV_URL, { cache: 'no-store' });
        if (!res.ok) {
          if (res.status === 403) throw new Error('Acesso negado à planilha. Verifique se ela está pública.');
          throw new Error(`Falha ao baixar CSV (status ${res.status}).`);
        }
        const text = await res.text();
        if (!text.trim()) throw new Error('CSV vazio retornado pela planilha.');
        return csvToMatrix(text);
      } catch (err) {
        throw new Error(`Erro ao acessar a planilha: ${err.message}. Verifique as permissões ou use um backend próprio.`);
      }
    }

    async function loadAndDraw(){
      setStatus('Carregando…');
      try{
        const matrix = await fetchCSV();
        normalizeData(matrix);
        hydrateUI();
        draw();
        setStatus('Dados carregados');
        els.kpiAt.textContent = new Date().toLocaleString('pt-BR');
      }catch(err){
        setStatus('Erro ao carregar');
        console.error(err);
        alert(`Erro ao carregar dados: ${err.message}`);
      }
    }

    function hydrateUI(){
      const prevCat = els.category.value;
      els.category.innerHTML = '';
      if (DATA.categories.length === 0) {
        els.category.innerHTML = '<option value="">Nenhuma categoria disponível</option>';
        return;
      }
      DATA.categories.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        els.category.appendChild(opt);
      });
      if (prevCat && DATA.categories.includes(prevCat)) els.category.value = prevCat;
      else if (DATA.categories.length) els.category.value = DATA.categories[0];
      draw(); // Garantir que o gráfico seja desenhado após hidratação
    }

    function getSeries(){
      const category = els.category.value;
      const view = els.view.value;
      const metric = els.metric.value;
      const row = DATA.rows.find(r => r['Categoria'] === category) || {};
      let labels, values;
      if (metric === 'N° Ocorrência') {
        labels = DATA.labels[view] || [];
        values = labels.map(label => coerceNumber(row[label]));
      } else {
        labels = ['Total'];
        values = [coerceNumber(row[metric])];
      }
      return { labels, values, category, metric };
    }

    // Função de debounce para otimizar redimensionamento
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function draw(){
      const { labels, values, category, metric } = getSeries();
      if (!labels.length || !values.length) {
        els.kpiTotal.textContent = '—';
        els.kpiPeak.textContent = '—';
        if (CHART) CHART.destroy();
        return;
      }
      const isDistributed = labels.length > 1;
      const total = values.reduce((a, b) => a + b, 0);
      els.kpiTotal.textContent = total.toLocaleString('pt-BR');
      if (isDistributed) {
        const maxV = Math.max(...values);
        const maxI = values.indexOf(maxV);
        els.kpiPeak.textContent = `${labels[maxI]}: ${maxV.toLocaleString('pt-BR')}`;
      } else {
        els.kpiPeak.textContent = '—';
      }

      const ctx = els.chart.getContext('2d');
      if (CHART) CHART.destroy();
      CHART = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: metric, data: values, borderWidth: 2, borderColor: 'rgba(0,230,255,.95)', backgroundColor: 'rgba(47,123,255,.20)', hoverBackgroundColor: 'rgba(124,77,255,.35)' }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 400 },
          plugins: {
            legend: { labels: { color: '#cfe6ff' } },
            title: { display: true, text: `${metric} — ${category || 'Nenhuma categoria'}`, color: '#eaf1ff', font: { weight: '800', size: 16 } },
            tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString('pt-BR')}` } }
          },
          scales: {
            x: { ticks: { color: '#cfe6ff' }, grid: { color: 'rgba(255,255,255,.05)' } },
            y: { beginAtZero: true, ticks: { color: '#cfe6ff' }, grid: { color: 'rgba(255,255,255,.06)' }, title: { display: true, text: 'Quantidade', color: '#cfe6ff' } }
          },
          devicePixelRatio: window.devicePixelRatio // Otimização para telas de alta densidade
        }
      });
    }

    const debouncedDraw = debounce(draw, 100);

    async function onChange(){
      try{
        const matrix = await fetchCSV();
        normalizeData(matrix);
        hydrateUI();
        debouncedDraw();
        els.kpiAt.textContent = new Date().toLocaleString('pt-BR');
      }catch(err){
        console.error(err);
        setStatus('Erro ao atualizar');
        alert(`Erro ao atualizar dados: ${err.message}`);
      }
    }

    els.category.addEventListener('change', onChange);
    els.view.addEventListener('change', onChange);
    els.metric.addEventListener('change', onChange);
    window.addEventListener('resize', debouncedDraw); // Adiciona debounce ao redimensionamento

    // Carga inicial automática
    loadAndDraw();
  });
  </script>
</body>
</html>
